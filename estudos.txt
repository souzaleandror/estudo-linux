Capitulo 1 Introducao

Existe outra solução mais elegante que faz uso tanto do VirtualBox quanto do VMware no seu background, o Vagrant http://www.vagrantup.com/.

Por padrão, o Ubuntu já instala uma suíte de aplicativos de escritório gratuita: o LibreOffice, que possui compatibilidade com os arquivos formatados no Microsoft Office.

Se estiver procurando um semelhante ao notepad do Windows, o Ubuntu pos- sui o Gedit.

Capítulo 2
Mão na massa: conhecendo o Shell

2.1 O que é o Shell?
O shell é a interface de acesso ao sistema operacional, onde é possível interagir com o sistema por meio de comandos digitados do teclado. Ele pode ser acessado pelo modo gráfico e diretamente em modo texto.

Abrindo o terminal (Shell)

• ubuntu é o nome do usuário;
• @servidor é o nome do host;
• ~ é a abreviação para a pasta do usuário;
• $ indica que o usuário não possui poderes de administrador.

Agora que entendemos o significado do prompt que aparece, vamos testar al- guns comandos e ver o que acontece.
daniel@casadocodigo:~$ pwd
/home/daniel
daniel@casadocodigo:~$ whoami
daniel
daniel@casadocodigo:~$ date
Thu Sep 26 21:30:07 UTC 2013
daniel@casadocodigo:~$

Ao executar o comando pwd, o retorno foi exatamente o diretório que estamos atualmente chamando de current.
O comando whoami exibe o nome do usuário atual que estamos usando e o date retorna a data atual.
Não se preocupe ainda sobre os poderes de administrador sudo, veremos isso mais adiante.

Existe a opção de vermos essa lista completa, graças ao history, que cria um histórico memorizando tudo o que já digitamos no shell

Outra recomendação para um uso mais produtivo do shell é utilizar a tecla tab, que possui a função de autocompletar.

Ao executar o comando cd / estamos informando ao Shell que queremos na- vegar até o diretório /, mais conhecido como raiz (ou diretório root). A instrução cd é o que permite a navegação entre diretórios.
Já o comando ls lista os arquivos e diretórios, neste caso no diretório raiz, que é onde estamos.

ara fazer a limpeza da tela usamos o comando clear. Teste o comando e veja o resultado. O atalho Ctrl + l tem o mesmo efeito.

Para retornar, temos algumas opções para combinar com o comando cd: • ~ aponta direto para o diretório home do usuário (ou pasta do usuário);
• ~ aponta direto para o diretório home do usuário (ou pasta do usuário);
• /home/ubuntu é o caminho absoluto;
• - último diretório onde esteve.

Agora que voltamos ao nosso diretório home, vamos criar um novo diretório usando o comando mkdir. Chamaremos de aplicativos

Para voltar, usamos o cd .. que significa volte para o diretório anterior.

Utilizando o comando touch, criamos um novo arquivo chamado meu_arquivo. Em seguida usamos o comando mv, passando como parâme- tro o nome do arquivo e o destino para mover o arquivo que criamos. 

Para isso, existe o comando cp, que faz uma cópia do arquivo mantendo o ori- ginal. 

daniel@casadocodigo:~$ cp aplicativos/meu_arquivo .

Observe a legibilidade: estamos falando para o shell copiar o arquivo meu_arquivo que se encontra em aplicativos para o diretório atual, e tudo foi feito sem sair da pasta home. 

Antes de prosseguir vamos ver um pouco sobre arquivos ocultos. Um arquivo oculto é identificado por um "." no início do nome, por exemplo ( .profile). Arquivos ocultos não aparecem em listagens normais de diretórios, para isso usamos um parâmetro no comando ls, ls -a ou, no formato mais detalhado, ls -la. No Ubuntu existe um atalho para esse comando, o ll.

O comando mv também serve para renomear um arquivo. Vamos renomear o arquivo que criamos meu_arquivo para meu_arquivo.txt, adicionando a extensão .txt

Nosso arquivo atualmente está vazio. Vamos escrever algum texto nele e conhe- cer mais um comando, o echo. O echo é utilizado para exibir mensagens na tela ou em um arquivo:
daniel@casadocodigo:~$ echo "Exibindo mensagem na tela"
Exibindo mensagem na tela
daniel@casadocodigo:~$

Agora vamos escrever algo no nosso arquivo com o echo, mas para isso é ne- cessário fazer uso do parâmetro >, confira:
daniel@casadocodigo:~$ echo Escrevendo no arquivo > meu_arquivo.txt

Agora podemos verificar o texto que foi inserido no nosso arquivo, com o co- mando cat

É interessante saber informações sobre o tipo de arquivo, para isso existe o co- mando file

Com o file podemos ver que o nosso arquivo é do tipo text, nota-se também que ao executar o file em um diretório, ele informa o tipo directory. Isso acontece pois no Linux tudo é considerado um arquivo.

agora que já sabemos criar arquivos, e manipular de forma básica, hora de apren- der a remover. Usando o rm podemos deletar arquivos e diretórios

O comando rmdir é responsável por remover diretórios, mas somente diretó- rios vazios.

Usando o rm -r vamos conseguir remover o diretório, o -r é uma opção do comando rm que faz ele remover diretórios que tenham conteúdo de forma recur- siva

2.5 Pedindo ajuda
Sempre que precisarmos de ajuda no Linux, podemos usar o help ou podemos incluir o parâmetro --help, que é suportado na maioria dos comandos.


No Linux a documentação padrão é chamada de man pages, ela contém ajuda para todos os comandos padrões. Vamos ao teste, execute o comando man ls e veja o que ele retorna

O man apresenta todos os tópicos do manual linux, de forma semelhante a um manual impresso e está presente em qualquer distribuição linux. O ambiente apre- sentado pelo man aceita comandos para navegação e busca na documentação:
• h mostra a ajuda do comando man, veja para mais detalhes; • qsairdoman;
• / procura por um texto na documentação apresentada;
• f avança uma tela;
• b volta uma tela.

Obtendo a descrição de comandos
É interessante saber que podemos verificar uma descrição simples de um co- mando, para isso podemos usar o whatis

Localizando arquivos no sistema

A sintaxe do find recebe alguns parâmetros: find [caminho] expressão [ação]

Indicamos o caminho a partir do qual ele irá procurar os arquivos, a expressão na qual podemos definir os critérios de busca e a ação com a qual informamos o que deve ser feito com os arquivos que atenderem aos critérios da busca.
Alguns dos critérios de busca definidos em expressão:
• -name procura arquivos pelo nome;
• -user procura arquivos pelo nome do usuário dono do arquivo;
• -atime procura arquivos que foram acessados há mais de x dias, onde x é o número de dias.

Perceba que informamos o caminho . (que significa aqui), a expressão -name \*.bash*, que quer dizer “busque pelo nome todos os arquivos que contenham a palavra bash no corpo do seu nome”, e a ação -print que é o padrão quando não especificamos de forma explícita.

Teste outra forma de busca com a expressão -atime:
daniel@casadocodigo:~$ find . -atime +1
./.bash_logout
daniel@casadocodigo:~$
No exemplo, o -atime +1 busca por arquivos que forma modificados há mais de 1 dia. Teste o mesmo comando informando -1 desta forma ele retornará arquivos modificados a menos de 1 dia.

Um passeio fora do ambiente gráfico

Além do ambiente gráfico no Linux, existe ainda 6 ambientes de linha de comando, conhecidos pelo nome de TTY (TeleTYpe) ou ainda terminais virtuais. O TTY cor- responde ao tipo dos primeiros terminais usados em computadores.

Para ter acesso a esses ambientes, usamos uma combinação das teclas Ctrl + Alt + FsendoqueFcorrespondedasteclasF1aF6,aF7retornaaoambientegrá- fico.

Capítulo 3
Manipulando arquivos

O Vi é o editor básico disponível em grande parte das distribuições Linux. Atual- mente este editor é oferecido com mais recursos e recebe o nome de Vim (VI iMpro- ved). O Vim é um editor de aspecto simples, porém bastante flexível. Em seguida, veremos o básico sobre ele.

Ao entrar no vi, ele é aberto direto no modo visual. Para editar um arquivo, usamos os modos de inserção, substituição e deleção. Sempre que precisamos voltar ao modo visual, usa-se a tecla Esc.

No vim podemos navegar pelo arquivo usando as teclas direcionais ou as teclas h, j, k e l:
• h, move para a esquerda;
• j, move para baixo (próxima linha); • k, move para cima (linha anterior);
• k, move para cima (linha anterior);
 l, move para a direita.
Mais comandos que facilitam a movimentação:
• G move para a última linha do arquivo;
• gg move para a primeira linha do arquivo; • 0 move o cursor para o início da linha;
• $ move o cursor para o final da linha.

Alguns comandos básicos para ajudar na inserção de texto:
• i para inserir texto antes do cursor;
• a para inserir texto depois do cursor;
• A para inserir texto no final de uma linha onde se encontra o cursor; • o para adicionar uma linha abaixo da linha atual;
• O para adicionar uma linha acima da linha atual.


Temos também comandos para alteração e localização no modo visual:
• x deleta o caractere onde está o cursor;
• dd deleta a linha atual;
• u desfaz a última modificação no arquivo;
• yy copia uma linha, p cola o que foi copiado;
• /palavra busca pela palavra ou caractere em todo o arquivo.

https://code.google.com/p/vimbook/

Se preferir um screencast, o Fabio Akita disponibilizou gratuitamente um vídeo com 1 hora de duração sobre o vim para iniciantes:
http://blip.tv/akitaonrails/screencast-come-ando-com-vim-6075050

O editor Nano

Observando o menu inferior do editor nano notamos várias funções. Vale lem- brar que ^ é o mesmo que Ctrl, sendo assim ^G significa Ctrl + G.
Alguns comandos básicos do nano:
• ^G apresenta a tela de ajuda sobre mais comandos do editor;
• ^Xsaidoeditor;seoarquivonãoestiversalvoserásolicitadoparasalvarantes de sair;
• ^O salva um arquivo;
• ^W busca por uma palavra dentro do arquivo.


3.3 Trabalhando com o Cat

Faça cat > agenda e tecle Enter. Em seguida digite as informações, e no final tecle Ctrl + d. Isto vai encerrar a digitação e salvar os dados no arquivo agenda

O cat disponibiliza opções para exibir <TAB> no arquivo -t, o fim das linhas de um arquivo, ou seja, onde demos ENTER -e. Faça um teste com as duas opções

daniel@casadocodigo:~$ cat -et agenda

Note que foram exibidos caracteres ^, que representam o <TAB>, e o $, que representa o fim da linha ou <ENTER>. Existe também a opção de enumerar as linhas -n

daniel@casadocodigo:~$ cat -n agenda

Vamos à instrução de concatenação de arquivos. Para isso faça o seguinte: cat vim_basico.txt agenda > concatenando.txt:
daniel@casadocodigo:~$ cat vim_basico.txt agenda > concatenando.txt

3.4 Exibindo o início e o fim de arquivos
É interessante saber sobre dois comandos com a função de exibir o conteúdo de um arquivo do cat: são eles o head e tail.

O head mostra o início dos dados em um arquivo. Por padrão ele exibe as 10 primeiras linhas do arquivo, mas utilizando a opção -n podemos limitar o número de linhas:
daniel@casadocodigo:~$ head -n 3 concatenando.txt

Já o tail mostra o final dos dados do arquivo e possui a mesma opção para limitar a quantidade de linhas, -n:
daniel@casadocodigo:~$ tail -n 5 concatenando.txt

Capítulo 4
Compactação e descompactação de arquivos

4.1 Conhecendo o tar
O tar é excelente para agrupar vários arquivos em apenas um. Isso, na prática, evita que precisemos fazer várias transferências de arquivos entre computadores, en- viando apenas um único arquivo. Isso vai aparecer muito no decorrer do seu uso do Linux. É importante conhecê-lo bem.
Basicamente existem três tipos de arquivos que são utilizados com o .tar: tar.gz ou .tgz e .tar.bz2.
Ao utilizarmos o .tar, ele realiza uma cópia sem compactação dos arquivos

passados como parâmetro, ou seja ele junta todos os arquivos em um único arquivo sem compactar.
Algumas opções do tar:
• -c cria um novo arquivo .tar e adiciona os arquivos a serem compactados; • -f indica que o destino é um arquivo em disco;
• -v exibe o nome de cada arquivo compactado;
• -x extrai os arquivos agrupados no arquivo .tar.

Vamos testar o .tar na prática, juntaremos todos os nossos arquivos que ter- minam em .txt em apenas um. Para isso usaremos as opções -c e -f:

daniel@casadocodigo:~$ tar -cf backup.tar *.txt

Note que foi criado um arquivo chamado backup.tar, que representa a união de todos os arquivos com extensão .txt.
Vamos fazer o reverso desta união, separando os arquivos usando as opções -x, -v e -f. Criaremos um novo diretório para melhor visualizar

daniel@casadocodigo:~/backup$ tar xvf backup.tar

O que acabamos de fazer foi criar uma pasta chamada backup, mover o arquivo backup.tar para dentro da pasta criada e fazer o processo reverso para separar os arquivos.

O tipo .tar.gz
O .tar.gz consiste em dois processos diferentes e interligados, sendo que pri- meiro ele cria um arquivo .tar e, em seguida, compacta utilizando o formato .gz. Neste caso, além de gerar um único arquivo com o .tar, ele será compactado, re- duzindo assim o seu tamanho.
Ainda dentro da pasta backup, vamos testar a criação do nosso arquivo dessa vez compactado com .tar.gz

daniel@casadocodigo:~/backup$ tar zcvf backup.tar.gz *.txt

Note que agora temos o backup.tar.gz, o mesmo arquivo unido .tar, mas compactado com .gz. Podemos verificar o tamanho dos arquivos com o comando du para melhor entender o real efeito da compactação:
daniel@casadocodigo:~/backup$ du -h backup.tar backup.tar.gz

Veja que usando o .tar.gz o arquivo foi reduzido para 4 kbytes! Para descom- pactar arquivos .tar.gz usa-se as opções zxvf:
daniel@casadocodigo:~/backup$ tar zxvf backup.tar.gz

O tipo .tar.bz2
Com o .tar.bz2 ocorre o mesmo caso que com o .tar.gz: a compactação com o formato .bz2 é mais eficiente que o .gz, porém é mais lenta na hora de gerar a cópia.
Vamos criar um arquivo compactado com .tar.bz2 utilizando as opções jcvf e conferir a diferença entre os tamanhos com o comando du:
daniel@casadocodigo:~/backup$ tar jcvf backup.tar.bz2 *.txt

Não houve diferença entre os tamanhos nos formatos .gz e .bz2, já que esta- mos compactando pequenos arquivos texto. Porém é possível notar a diferença em arquivos maiores, por exemplo uma imagem ISO de um DVD.
Para fazer a descompactação de formatos .bz2 usamos as opções jxvf:
daniel@casadocodigo:~/backup$ tar jxvf backup.tar.bz2

Podemos notar que, sempre que vamos compactar, a opção c é utilizada; e ao realizar a descompactação usamos a opção x. Já para o formato .tar.gz, usamos a opção z, e a opção j para o formato .tar.bz2.
Pode parecer um pouco complicado memorizar todas essas opções no inicio, mas com a prática isso acaba se tornando natural.

4.2 Conhecendo o gzip/gunzip
Este é o programa de compressão mais utilizado no Linux. O gzip gera um arquivo no formato .gz. Sua forma de uso para compactar é bastante simples:
daniel@casadocodigo:~/backup$ gzip -c -r *.txt > backup.gz

As opções -c e -r respectivamente informam que queremos criar um arquivo e compactar. Ao executarmos a compactação de vários arquivos utilizando o gzip, os arquivos serão concatenados em um só e em seguida comprimidos no formato .gz

Para descompactar usamos o gunzip, que pode ser utilizado com as opções -c e -v para exibir o conteúdo a ser descompactado e informações sobre o nível de compactação dos arquivos:
daniel@casadocodigo:~/backup$ gunzip backup.gz

No exemplo, ao executar a descompactação com gunzip, o nosso arquivo backup.gz deixará de existir pois por padrão o gunzip extrai o arquivo com- primido no formato .gz e exclui o arquivo compacto.

4.3 Conhecendo o zip/unzip

O comando zip, como o nome já sugere, cria um arquivo compacto no formato .zip, enquanto o unzip faz o trabalho inverso, descompactando.
A forma de uso é muito simples:
daniel@casadocodigo:~/backup$ zip backup.zip *.txt

Para descompactar, use o comando unzip:
daniel@casadocodigo:~/backup$ unzip backup.zip

Capítulo 5
Entendendo a estrutura de diretórios

A estrutura de diretórios

Cada diretório do sistema possui arquivos que são mantidos seguindo regras defini- das pela FHS (Filesystem Hierarchy Standard). No Ubuntu a estrutura de diretórios segue o padrão LSB (Linux Standard Base), que por sua vez segue a especificação do FHS. Esses padrões são importantes pois ajudam a manter a compatibilidade entre as variações de distribuições Linux.

Nesta estrutura, o FHS determina que obrigatoriamente uma distribuição Linux deve conter 14 diretórios. Veremos cada um deles

5.3 Os diretórios /proc e /sys

O diretório /proc contém arquivos temporários de processos em execução no sis- tema. Em outras palavras, é um diretório virtual usado pelo kernel. Nele são man- tidos configurações atuais do sistema e dados estatísticos.

Assim como o diretório /proc, o /sys armazena quase o mesmo conteúdo porém de forma mais organizada para podermos administra

Capítulo 6
Administração de usuários

As restrições implementadas no sistema de permissões são muito eficientes. Esse esquema de permissões é fundamental para o funcionamento do sistema por com- pleto. As permissões consistem em um conjunto de três regras: leitura, escrita e execução. É graças a esse esquema de permissões que não vemos sistemas Linux infectados por malwares ou vírus.

Gerenciando usuários
Para entender sobre o controle de usuários, vamos dividir esta seção em três catego- rias:
1) SuperUsuário(sudo)ou Administrador;
2) Usuário de Sistema;
3) Usuário Comum.

Usuário Administrador e sudo
No sistema, esse usuário é chamado de root. Ele é responsável por controlar todo o sistema e não possui restrições. Sempre que executamos algum programa ou tarefa que necessite de poderes administrativos, precisamos do root, que é chamado por meio do comando sudo.

Usuários de sistema
São usuários que não necessitam logar no sistema – eles existem para contro- lar serviços e normalmente não possuem senhas. Um bom exemplo é o usuário www-data, que pode ser usado para administrar servidores web como Apache e Nginx.

Usuários comuns
São as contas criadas para o utilizadores do sistema. Essencialmente, eles podem executar tarefas básicas como criar e editar documentos, navegar na internet, assistir vídeos etc. A conta daniel é um exemplo de usuário comum, diferente da conta root que é utilizada para administrar o sistema.

6.2 Permissões
Nesta seção abordaremos o suficiente para termos uma referência sobre permissões de arquivos e usuários. As permissões são opções que permitem um usuário ter controle de acesso, leitura, gravação e execução de arquivos.
Existem três tipos de permissões: r (leitura), w (escrita) e x (execução).

Para listar as permissões de um arquivo ou diretório, podemos usar o comando ls, seguido da opção -l (long listing). Assim teremos uma listagem detalhada dos arquivos:
daniel@casadocodigo:~$ ls -l

No começo, isso pode parecer grego para nós. É comum uma pequena dificul- dade até se acostumar com tantas letrinhas e abreviações. Vamos entender detalha- damente o significado da listagem exibida:
• -: significa “desabilitado” ou permissão negada;
• r: permissão de leitura, apenas lê um arquivo;
• w: permissão de escrita, pode escrever em arquivos e diretórios;
• x: permissão para executar um arquivo.

A aplicação de permissões aos arquivos está ligada a três entidades, que são clas- ses de acesso aos arquivos:
• u: usuário dono do arquivo;
• g: grupo a que o arquivo pertence;
• o: outros usuários que não sejam o dono nem pertençam ao grupo.
Quando listamos com ls -l, os 10 primeiros caracteres indicam o modo do arquivo:

6.3 Atribuindo permissões
O chmod é o comando para atribuir permissões de arquivos. Basicamente, ele atua diretamente nos níveis dono, grupo e outros.
A sintaxe de uso do chmod é a seguinte: chmod [opções] modo arquivo
O modo pode ser representado utilizando notação simbólica ou octal, veremos as duas formas. A seguir, uma lista das opções para o comando:
• -c: lista informações sobre os arquivos modificados;
• -f: ignora mensagens de erro;
• -R: modo recursivo, altera as permissões de todos os arquivos e diretórios; • -v: lista de forma detalhada as alterações de atributo.
Antes de prosseguir é importante entendermos sobre bits de atributo! 

Bits de atributo

Bits de atributo são um controle adicional às permissões de arquivos. As entida- des dono, grupo e outros têm suas configurações setadas pelo dono do arquivo. Essas configurações podem ser representadas também pelos bits de atributo, ou seja, assim como existem três entidades, também existem três bits de atributo, que podem estar ligados ou desligados:
Bit SetUID permite que um arquivo seja executado da mesma forma que é exe- cutado pelo dono.
Bit SetGID permite que um arquivo seja executado como se fosse parte do grupo de seu dono. Quando um arquivo é criado em um diretório que possui este bit ativo, ele é criado com o mesmo grupo do diretório.
Bit Sticky ativa uma proteção para o arquivo e não permite que ele seja apagado, a não ser pelo próprio dono.
A representação simbólica destes bits é lida da esquerda para a direita através das siglas SST, onde o primeiro S representa o SetUID, o segundo S representa o SetGID e o T representa o Sticky. Para indicar se um bit está ativo ou inativo, usa-se (1 ou +) para ativo e (0 ou -) para inativo.

Os tipos de notações

A notação octal converte cada grupo de três bits em um caractere que vai de 0 a 7.
Grupos:
Simbólica:
Binária:
Octal:         7         5         4
Dono  |   Grupo   | Outros
rwx       r-x       r--
111       101       100

Podemos notar que o arquivo possui permissão de leitura e escrita para o dono e grupo, e permissão de apenas leitura para outros. Fazendo uso do chmod vamos alterar as permissões deste arquivo:
daniel@casadocodigo:~$ chmod u=rw,g=rw,o=rw agenda

Teste o chmod usando a opção -v e veja a informação que ele retorna:
daniel@casadocodigo:~$ chmod -v 664 agenda

Retornamos a permissão anterior usando o formato octal. A opção -v do chmod nos mostra duas notaçõesm, de modo que fica fácil comparar e entender o que estamos fazendo.

6.4 Criando grupos

Agora que já entendemos um pouco sobre usuários, grupos e permissões, vamos praticar e conhecer mais alguns comandos.
Sabemos que um usuário deve pertencer a um grupo e pode ser adicionado a ou- tros grupos. Para criar um novo grupo, usamos o comando addgroup – criaremos um grupo chamado suporte:
daniel@casadocodigo:~$ sudo addgroup suporte

Note que, ao criar o grupo automaticamente, ele recebe o seu número GID.

riando usuários
Para criar usuários, existe o comando adduser, que pode também adicionar usuá- rios em grupos e até criar novos grupos.
adduser pauloiráadicionarousuáriopaulosolicitandoasinformaçõesadi- cionais como: nome, senha, grupo, pasta home

daniel@casadocodigo:~$ id paulo

Agora que já criamos um novo grupo e um novo usuário, vamos adicionar o usuário paulo ao grupo suporte. Para isso, utilize o comando addgroup que,além de criar um novo grupo como vimos anteriormente, também pode adicionar usuários a outros grupos:
daniel@casadocodigo:~$ sudo addgroup paulo suporte

6.6 Alterando grupos
Como vimos no inicio do capítulo, cada arquivo e diretório possui um dono e um grupo. Tanto o dono como o grupo ao qual um arquivo ou diretório pertence podem ser alterados. Para isso, usamos os comandos chown e chgrp.
Para testá-los, vamos usar o arquivo agenda que criamos anteriormente:
daniel@casadocodigo:~$ ls -l agenda

Capítulo 7
Instalando pacotes e aplicativos

Primeiramente, vamos entender o que é um pacote. Um pacote é um conjunto de arquivos agrupados para facilitar a instalação e distribuição de um programa. Ele pode conter scripts para listagem e checagem de dependências para configuração durante o processo de instalação de um aplicativo.
No Ubuntu os pacotes são baseados em Debian e têm a extensão .deb.

7.1 Gerenciador de pacotes

7.2 Gerenciando pacotes com APT

Veremos aqui um pouco sobre gerenciamento de pacotes no terminal utilizando a ferramenta APT (Advanced Packaging Tool). Para isso, usaremos o comando apt-get, que é uma interface para a ferramenta APT. Assim como o apt-get, existe outra interface para o APT, o aptitude. Mas em nossos estudos usaremos o apt-get para instalar, atualizar e remover aplicativos.

Antes de prosseguir, vamos entender algumas opções do apt-get:
• update: atualiza a lista de pacotes;
• upgrade: atualiza todo o sistema;
• install: instala um novo programa;
• remove: desinstala um programa.

Para entender melhor como funciona o apt-get, vamos fazer a instalação do Java. O pacote Oracle JDK foi removido do repositório oficial do Ubuntu de- vido à nova licença do Java. Por conta disso, usaremos um repositório alternativo para instalar o pacote do Java.

daniel@casadocodigo:~$ sudo add-apt-repository ppa:webupd8team/java

Após adicionar a nova fonte de repositório, é necessário atualizar a lista de pa- cotes – usaremos a opção update:

daniel@casadocodigo:~$ sudo apt-get update
Depois de atualizar a lista de pacotes, vamos finalmente instalar o Java, usando a opção install:
daniel@casadocodigo:~$ sudo apt-get install oracle-java7-installer

Ao rodar o comando anterior, o APT vai informar o que será instalado junto com as dependências. Quando o APT perguntar se deseja continuar, tecle Y para informar que sim:
daniel@casadocodigo:~$ sudo apt-get install oracle-java7-installer

Capítulo 8
Prática, instalando Apache, PHP e MySQL

daniel@casadocodigo:~$ apt-get update
[sudo] password for daniel:
Informe a senha do seu usuário e prossiga com o processo de atualização. Em seguida, podemos instalar o pacote build-essential:
daniel@casadocodigo:~$ sudo apt-get install build-essential

Agora instale o pacote apache2. Serão listadas as dependências que serão ins- taladas junto ao pacote apache2 – o sistema deve solicitar a confirmação para pros- seguir com a instalação. Faça:
daniel@casadocodigo:~$ sudo apt-get install apache2
Sempre que quiser obter informações sobre um pacote, utilize o comando apt-cache, que possui a seguinte sintaxe apt-cache show pacote. Faça um teste com o pacote apache2:
daniel@casadocodigo:~$ sudo apt-cache show apache2

gora que temos o web server Apache instalado e funcionando, podemos fazer testes para entender sobre serviços. Após a instalação, o web server fica disponível no sistema em forma de serviço; sendo assim, usaremos o comando service para verificar as opções disponíveis para o serviço apache2 que instalamos:
daniel@casadocodigo:~$ sudo service apache2
 * Usage: /etc/init.d/apache2 {start|stop|graceful-stop|restart|reload|
 force-reload|start-htcacheclean|stop-htcacheclean|status}
 daniel@casadocodigo:~$
Note que o comando service executa o script de serviços apache2 locali- zado em /etc/init.d/apache2, que possui as várias opções como iniciar, parar, restartar e outras.

daniel@casadocodigo:~$ sudo service apache2 stop

8.2 Linkando arquivos

O apache faz bastante uso de linkagem de arquivos em suas configurações, assim, agora temos exemplos mais ricos.
Para fazer um link, utilizamos o comando ln -s, que cria um link simbólico para o arquivo de origem – seu conteúdo é o caminho do arquivo. Para entender melhor, observe a listagem nas configurações do apache:
daniel@casadocodigo:/etc/apache2/sites-enabled$ ls -l

8.3 Instalando e configurando o MySQL
Vamos prosseguir instalando e configurando o MySQL. Ele é um sistema de geren- ciamento de banco de dados relacional bastante popular, muito usado em conjunto com aplicações bem conhecidas como o WordPress.

O primeiro passo é instalar o pacote mysql-server, e para isso faça: daniel@casadocodigo:~$ sudo apt-get install mysql-server

Após a instalação, verifique se o serviço mysql está rodando em seu sistema. Use o comando service com a opção status:
daniel@casadocodigo:~$ sudo service mysql status

Agora teste o mysql efetuando login no serviço com o usuário root: daniel@casadocodigo:~$ sudo mysql -u root -p
Enter password:
O mysql solicitará a senha de root que foi definida no processo de instalação. Após informá-la, você verá uma tela como a seguinte:

Assim como o apache, o mysql também é um serviço e, como tal, possui as mesmas regras disponíveis no service. Isso possibilita parar, iniciar, recarregar, ver o status, igual fizemos no apache:
daniel@casadocodigo:~$ sudo service mysql stop
mysql stop/waiting
daniel@casadocodigo:~$ sudo service mysql status
mysql stop/waiting
daniel@casadocodigo:~$ sudo service mysql start
mysql start/running, process 12089
daniel@casadocodigo:~$ sudo service mysql status
mysql start/running, process 12089
daniel@casadocodigo:~$

8.4 Instalando e configurando o PHP

daniel@casadocodigo:~$ sudo apt-get install php5 php-pear php5-mysql

Agora que instalamos o php, precisamos ajustar o seu arquivo de configuração
que está em /etc/php5/apache2/php.ini.

mais descritivas e ativar logs. Para isso, vamos editar o php.ini. Utilize o vim ou nano:
daniel@casadocodigo:~$ sudo vim /etc/php5/apache2/php.ini

Com o arquivo aberto, busque por error_reporting. No vim, faça:
/error_reporting =
Essa instrução no vim irá buscar pelo texto error_reporting = no arquivo. Após encontrar, edite a linha e faça a seguinte alteração:
De:
error_reporting = E_ALL & ~E_DEPRECATED
Para:
error_reporting = E_COMPILE_ERROR|E_RECOVERABLE_ERROR|E_ERROR|
E_CORE_ERROR

Desta forma, estamos alterando o formato das mensagens de erro do php para serem mais descritivas. Agora vamos especificar o arquivo de logs onde o php deverá salvar: busque no vim a diretiva error_log = e descomente apagando o ; no inicio da linha. Em seguida, insira o seguinte caminho:
error_log = /var/log/php.log
Pronto, agora os logs do php irão ser salvos no arquivo php.log localizado no diretório /var/log. Salve o arquivo, saia do editor e no vim faça: :wq.

daniel@casadocodigo:~$ sudo service apache2 reload

Crie um novo arquivo chamado de teste.php em /var/www, e com o vim faça:

daniel@casadocodigo:~$ sudo vim /var/www/teste.php Insira no arquivo o seguinte trecho de código:

<?php
phpinfo(); ?>

Salve o arquivo e saia do editor com :wq; em seguida confira o resultado no browser, acessando http://localhost/teste.php.

Capítulo 9
Entendendo processos

9.1 O que são processos?
A definição de processo apresentada por Tanenbaum no livro Sistemas Operacio- nais - Projeto e Implementação:
A ideia-chave aqui é que um processo é um tipo de atividade. Ele tem um programa, entrada, saída e um estado. Um único processador pode ser compartilhado entre vá- rios processos, com algum algoritmo de agendamento sendo utilizado para determinar quando parar de trabalhar em um processo e servir a um diferente

Um processo possui estados que definem o seu comportamento, são eles:
• execução: o processo está ativo utilizando a CPU e outros recursos;
• pronto ou espera: o processo está temporariamente parado permitindo
que outro processo execute na sua frente;
• bloqueado: o processo está parado aguardando a execução de algum evento
para voltar ao estado de execução.

Cada processo no Linux recebe um número para sua identificação conhecido por PID. Podemos vê-los com o comando ps:
daniel@casadocodigo:~$ ps aux

9.3 A identificação de processos
Como vimos, um processo é identificado por seu PID (Process Identifier). Esse número é dado pelo sistema para cada processo, cada PID é único, então você nunca verá dois ou mais processos fazendo uso do mesmo PID.

Cada processo também possui um usuário dono, dessa forma, o sistema veri- fica as permissões e sabe qual usuário pode executar um determinado processo. A identificação de donos é feita pelos números UID e GID.
No Linux, todo usuário possui um número de identificação da mesma forma que os processos. Esse número é conhecido por UID (User Identifier) e o GID (Group Identifier).

Execute o ps para obter a lista de processos do nosso usuário: daniel@casadocodigo:~$ ps
 PID TTY
1788 pts/0
1847 pts/0
    TIME CMD
00:00:00 bash
               00:00:00 ps
daniel@casadocodigo:~$
No caso, o usuário daniel possui apenas 2 processos em execução: o bash, que é o processo do shell, e o próprio ps, que foi o processo criado ao executar o comando ps.

Assim como todos os comandos que vimos até agora, o ps também possui op- ções. Veremos algumas delas:
• a: lista todos os processos existentes;
• u: exibe o nome do usuário dono do processo;
• x: lista os processos que não possuem relação com o terminal; • m: exibe a quantidade memória consumida por cada processo.

daniel@casadocodigo:~$ ps aux

Podemos contar todos os processos em execução fazendo uso de um comando que ainda não testamos: o wc. Basicamente o que ele faz é contar as linhas de um arquivo ou do conteúdo que for exibido no terminal, para isso utilizamos a opção wc -l. Para informar ao comando que queremos apenas a quantidade de linhas, o que faremos é executar o ps aux em combinação com o wc -l, usando o | (pipe), que é uma forma de encadeamento de processos:
daniel@casadocodigo:~$ ps aux | wc -l

O que o | fez foi encadear a execução do comando ps aux ao comando wc -l. Assim, ele pegou o resultado gerado do primeiro comando e passou para o se- gundo. A saída do wc nos mostra quantos processos ao todo temos rodando em nosso computador.

Outro comando que ainda não vimos é o grep, que procura por uma expressão que pode ser uma palavra ou frase em um arquivo, ou ainda pode funcionar como filtro na saída de comandos. Vamos usá-lo para filtrar a lista de processos gerada com ps -A e buscar todos os processos do apache que estiverem em execução. A opção -A do comando ps é para exibir todos os processos em execução mas sem detalhes.
daniel@casadocodigo:~$ ps -A | grep apache

Veremos agora outro comando bastante usado para verificar processos, o top, que acompanha os processos atualizando as informações quase em tempo real. Exe- cute no terminal o top para vê-lo funcionando:

Uma opção interessante é acompanhar os processos de um determinado usuário do sistema. Para isso usamos a opção -u e o nome do usuário:

daniel@casadocodigo:~$ top -u daniel

Uma outra opção ao top é o htop, que tem uma interface mais amigável. Ele não vem instalado por padrão, então vamos instalar para conhecê-lo:
daniel@casadocodigo:~$ sudo apt-get install htop Após a instalação, execute htop:

9.5 O que são sinais de processos?
No Linux os sinais são uma forma de comunicação usada pelos processos para que o sistema consiga interferir em seu funcionamento. Na prática, ao receber um si- nal com instruções, um processo interpreta a ação que foi especificada no sinal e a executa.
Alguns dos sinais mais conhecidos e usados por processos são: • KILL: sinal com função de encerrar um processo;
• TERM: termina o processo após ele finalizar uma tarefa;
• STOP: interrompe a execução de um processo;
• CONT: ativa a execução de um processo que foi interrompido.

Vamos interromper a execução do mysql enviando um sinal de STOP para o seu processo. Precisamos primeiro do número PID do mysql:
daniel@casadocodigo:~$ ps -A | grep mysql

Agora que temos o número PID do processo do mysql, vamos enviar o sinal de STOP para ele, interrompendo sua execução:
daniel@casadocodigo:~$ sudo kill -STOP 1047

bra um novo terminal, envie o sinal CONT para ativar a execução do processo que foi interrompido e veja o que acontece no terminal onde estamos tentando nos conectar ao mysql:
daniel@casadocodigo:~$ sudo kill -CONT 1047
daniel@casadocodigo:~$
Ao executar o envio do sinal CONT para o processo interrompido do mysql, veja que ele voltou a funcionar normalmente.

Outro comando bastante usado é o killall, quando não sabemos o PID ou quando temos vários processos do mesmo aplicativo com vários PIDs em execução, por exemplo o apache:
daniel@casadocodigo:~$ ps -A | grep apache

Note que temos vários PIDs e, por isso, enviar um sinal de cada vez para cada PID torna-se complicado. Neste caso usamos o killall e o nome do processo em vez do PID. Para interromper a execução do processo, faríamos:
daniel@casadocodigo:~$ sudo killall -STOP apache2

Os estados de um processo
Basicamente existem 4 estados para um processo. Após sua criação, o seu es- tado corrente é executável; quando um processo está aguardando alguma ro- tina para ser executado, dizemos que ele está dormindo – esse estado é chamado de dormente –; se um processo está congelado e por algum motivo não pode ser exe- cutado, dizemos que seu estado é parado; se um processo é considerado morto, ou seja, foi finalizado, não está mais em execução mas por algum motivo ainda existe, dizemos que seu estado é de um processo zumbi.

9.6 Processos e suas prioridades

Em alguns casos, por exemplo tarefas de backup, setamos a prioridade para que o
processo não consuma de forma inesperada recursos do computador como memória e CPU. Nesses casos, podemos usar 2 comandos: o nice e o renice.
Por enquanto, vamos testar o renice e alterar a prioridade do processo que está executando o mysql:
daniel@casadocodigo:~$ ps -A | grep mysql

Agora que temos o PID do processo podemos alterar sua prioridade, para isso faça:
daniel@casadocodigo:~$ sudo renice -19 2340

Capítulo 10
Introdução a Shell Script

Shell Script é a linguagem de programação utilizada pelo shell – no caso o shell é o nosso interpretador que vai ler os nossos programas e dizer ao processador o que fazer.

10.1 O primeiro script
Vamos ver um exemplo de um programa bem simples:

#!/bin/bash
# Nosso primeiro programa em Shell Script
mkdir ~/relatorio
ps aux > ~/relatorio/processos.txt
echo "Programa executado com sucesso!"

10.2 Executando o script

Agora que alteramos a permissão do arquivo primeiro_programa.sh, po- demos executar da seguinte forma:
daniel@casadocodigo:~$ ./primeiro_programa.sh

10.3 Operações básicas

mo toda linguagem de programação, Shell Script também trabalha com opera- ções numéricas, variáveis e estruturas de controle. Vamos implementar um exemplo básico contando o número de linhas de um arquivo. Para isso, crie um arquivo cha- mado conta_linhas.sh com o editor de sua escolha e insira o seguinte conteúdo:


#!/bin/bash
echo "Contando as linhas ..."
sleep 5
LINHAS=`cat ~/relatorio/processos.txt | wc -l`
echo "Existem $LINHAS no arquivo."

10.4 Estruturas de controle
Vamos criar um pro- grama simples para verificar e informar se um arquivo existe no diretório home do nosso usuário. Para isso, crie um arquivo chamado verificador.sh:

#!/bin/bash
echo "Informe o nome do arquivo que deseja buscar:"
read ARQUIVO
CONSULTA=$(ls ~ | grep $ARQUIVO)
if [ -z $CONSULTA ]; then
  echo "$ARQUIVO não foi encontrado!"
else
  echo "Arquivo encontrado!"
fi

10.5 Realizando um backup agendado

No Linux, o crontab é responsável por agendar tarefas para serem executa- das em um período de tempo determinado. Ele é gerenciado por um serviço chamado crond, que verifica a existencia de agendamentos que devem ser executados. O crontab realiza 2 tipos de agendamentos, agendamento dos usuários e agenda- mento do sistema.

O comando crontab pode editar, listar e criar novos agendamentos para usuá- rios, veja as opções em crontab --help. Para verificar se existem tarefas agen- dadas para um determinado usuário faça:
daniel@casadocodigo:~$ crontab -u daniel -l


No exemplo ainda não existe uma tarefa agendada para o usuário daniel.
O agendamento dos usuários é armazenado em /var/spool/cron/crontabs. Já os agendamentos para o sistema ficam em /etc, distribuídos em diretórios que podem ser organizados em agendamentos por hora, dia, semana e mês:
daniel@casadocodigo:~$ ls -d /etc/cron.*

O que a instrução faz é listar a cada minuto o conteúdo de home do usuário daniel e inserir o output da listagem no arquivo crontab.txt que será criado também em home. Note o uso do >>, que significa que sempre será inserido o conteúdo da listagem sempre após a última linha do arquivo crontab.txt. Mas e esse monte de * ?
Cada * representa uma configuração no crontab, que indica:
• minuto: vai de 0 a 59; • hora:vaide0a23;
• dia:vaide1a31;
• mês:vaide1a12;
• dia da semana:vaide0a7.

10.6 Um simples script de backup

Vamos implementar agora o script para realizar o backup do diretório home do nosso usuário. Para isso, usaremos o comando tar e o comando date. O tar vai gerar uma cópia do home compactada, o date irá incrementar as cópias adicio- nando a informação do dia, mês, ano, hora e minuto em que o backup foi realizado.
Primeiro vamos criar uma pasta chamada backup no diretório raiz (/) do nosso sistema:

daniel@casadocodigo:~$ sudo mkdir /backup
Crie um arquivo chamado backup.sh. Use um editor de sua escolha e imple-
mente o seguinte script:
#!/bin/bash
# Script de backup /home/daniel
sudo tar czf /backup/$(date +%d%m%Y-%H%M)-home.tar.gz -C /home/daniel .

10.7 Personalizando o seu shell: PS1, PATH e outros

É importante saber que existem variáveis locais e globais, sendo que as variáveis locais são restritas a um escopo definido e as globais ficam disponíveis para todo o sistema. Estas últimas são bastante conhecidas por variáveis de ambiente. A dife- rença entre elas está na criação:

VARIAVEL_LOCAL="valor"
export VARIAVEL_GLOBAL="valor"

Para definir uma variável local, só precisamos atribuir um valor ao nome da va- riável. Para definir uma variável de ambiente, é necessário fazer uso do comando export antes de sua definição.

Uma outra variável de sistema muito importante é o PATH, que armazena os caminhos absolutos de arquivos binários (executáveis) de aplicativos. Eles podem ser chamados sem a necessidade de informarmos o caminho completo.
daniel@casadocodigo:~$ echo $PATH

Para melhor entender, busque o caminho absoluto do vim. Para isso, utilize o comando whereis:
daniel@casadocodigo:~$ whereis vim

Como o $PATH armazena o trajeto /usr/bin, não precisamos informar o ca- minho inteiro ao executar o aplicativo vim, que seria /usr/bin/vim. Isto serve para praticamente quase todos os aplicativos. Podem aparecer casos em que seja ne- cessário alterar o valor da variável PATH, o que pode ser feito em /etc/profile ou de maneira mais organizada separando por scripts em /etc/profile.d.

10.8 Alias
Outro recurso que usaremos bastante é o alias, que cria um apelido para uma determinada instrução. Sua sintaxe é parecida com a definição de uma variável.
Vamos ver a lista de alias que existe definida no sistema:
daniel@casadocodigo:~$ alias

Podemos criar o nosso próprio alias, por exemplo, para o comando clear. Em vez de digitarmos o clear para limpar o buffer do terminal, podemos ter um apelido chamado cl. Para isso, faça:
daniel@casadocodigo:~$ alias cl='clear'

10.9 Arquivos de configuração
Quando nos logamos no sistema e abrimos um shell, esse shell é de login interativo e executa várias instruções de configurações para, por exemplo, customizar o bash ou disponibilizar um novo alias.
Por padrão, ao logar no shell, ele vai ler o arquivo /etc/profile e executá- lo, aplicando as configurações para todos os usuários do sistema. Na sequência, após ler o /etc/profile, irá buscar por um dos seguintes arquivos, na pasta home do usuário:
• ~/.profile
• ~/.bash_profile • ~/.login
• ~/.bashrc

Para entender melhor, vamos criar um alias e defini-lo para ser carregado logo que chamamos um shell. No exemplo, vamos setar um novo alias apenas para o usuário daniel. Para isso, precisamos editar o arquivo .bashrc que existe na pasta home do nosso usuário:
daniel@casadocodigo:~$ vim .bashrc

alias cl='clear' # <--- Nosso novo alias

Capítulo 11
Compilando arquivos fonte
